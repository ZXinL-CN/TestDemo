// [https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js](https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js)
/**
* 大多数编译器分为三个主要阶段：解析、转换、和代码生成
*
* 1.*解析* 是将原始代码转换为更抽象的代码的表示。
*
* 2.*转换* 采用这种抽象表示并进行操作无论编译器想要什么。
*
* 3.*代码生成* 采用代码的转换表示形式和将其转换为新代码。
*/

/**
*解析
* -------
*
* 解析通常分为两个阶段：词法分析 和 句法分析。
*
* 1.*词法分析* 获取原始代码并将其拆分为这些东西由一种称为分词器（或词法分析器）的东西调用令牌。
*
* 令牌是描述孤立片段的微小物体数组
* 的语法。它们可以是数字、标签、标点符号、运算符、
*无论什么。
 *
* 2.*句法分析* 获取标记并将其重新格式化为
* 描述语法的每个部分及其关系的表示
* 彼此之间。这称为中间表示或
* 抽象语法树。

    抽象语法树（简称 AST）是一个深度嵌套的对象，它
* 以一种既易于使用又告诉我们很多信息的方式表示代码
* 的信息。
 *
 */

/**
*转型
 * --------------
 *
* 编译器的下一个阶段类型是转换。同样，这只是
* 从最后一步获取 AST 并对其进行更改。它可以操纵
*相同语言的AST，或者它可以将其翻译成全新的
*语言。
 */

/**
 * ============================================================================
* (/^▽^)/
* 分词器！
 * ============================================================================
 */

/**
* 我们将从第一阶段的解析开始，词法分析，与
* 分词器。
 *
* 我们只是将我们的代码字符串分解成一个数组
* 的代币。
 *
* (add 2 (subtract 4 2))   =>   [{ type: 'paren', value: '(' }, ...]
 */

//我们从接受一个输入字符串开始，我们将设置两件事。。。

function tokenizer(input) {
    //  一个“当前”变量，用于像光标一样跟踪我们在代码中的位置。
    let current = 0;

    // 还有一个“令牌”数组，用于将我们的令牌推送到。
    let tokens = [];

    // 我们首先创建一个“while”循环，在其中设置“当前”
    // 变量要尽可能多地增加，只要我们希望“在”循环内部。

    // 我们这样做是因为我们可能希望在
    // 单循环，因为我们的代币可以是任意长度。
    while (current < input.length) {
        // 我们还将在“输入”中存储“当前”字符。

        let char = input[current];

        // 我们要检查的第一件事是一个左括号。这将
        // 稍后用于“CallExpression”，但现在我们只关心
        // 字符。

        // 我们检查是否有一个左括号：
        if (char === '(') {
            // 如果我们这样做，我们推送一个类型为“paren”的新令牌并设置值
            // 到左括号。
            tokens.push({
                type: 'paren',
                value: '('
            })
            // 然后我们增加“当前”
            current++;

            // 我们“继续”进入循环的下一个周期。
            continue;
        }

        // 接下来，我们将检查右括号。我们做同样的事情
        // 和以前一样：检查右括号，添加新令牌，
        // 递增“当前”和“继续”。
        if (char === ')') {
            tokens.push({
                type: 'paren',
                value: ')',
            });
            current++;
            continue;
        }

        // 继续，我们现在要检查空格。这很有趣
        // 因为我们关心空格的存在是为了分隔字符，但它
        // 实际上对我们来说，存储为令牌并不重要。我们只会扔
        // 后来出来了。

        // 所以在这里，我们只是要测试是否存在，如果它确实存在，我们就会
        // 只是“继续”下去。

        let WHITESPACE = /\s/;
        if (WHITESPACE.test(char)) {
            current++;
            continue;
        }

        // 下一种类型的令牌是数字。这与我们拥有的有所不同
        // 以前见过，因为一个数字可以是任意数量的字符，我们
        // 希望将整个字符序列捕获为一个标记。

        //
        //   (add 123 456)
        //        ^^^ ^^^
        //        只有两个单独的令牌
        //

        // 因此，当我们遇到序列中的第一个数字时，我们就开始这样做。

        let NUMBERS = /[0-9]/;
        if (NUMBERS.test(char)) {
            // 我们将创建一个要推送的“值”字符串
            // 字符到。
            let value = '';

            // 然后我们将遍历序列中的每个字符，直到
            // 我们遇到一个不是数字的字符，推动每个字符
            // 这是我们“价值”的一个数字，并且随着我们的发展而递增“当前”。

            while (NUMBERS.test(char)) {
                value += char;
                char = input[++current];
            }

            // 之后，我们将“数字”令牌推送到“令牌”数组。
            tokens.push({
                type: 'number',
                value
            });

            //  我们继续前进。
            continue;
        }

        // 我们还将添加对我们语言中的字符串的支持，这些字符串将是任何
        // 用双引号 （“） 括起来的文本。
        //
        //   (concat "foo" "bar")
        //            ^^^   ^^^ string tokens
        //

        // 我们将首先检查开场白：
        if (char === '"') {
            //  保留一个“value”变量来构建我们的字符串令牌。
            let value = '';

            // 我们将跳过令牌中的开头双引号。
            char = input[++current];

            // 然后我们将遍历每个角色，直到到达另一个角色
            // 双引号。
            while (char !== '"') {
                value += char;
                char = input[++current];
            }

            // 跳过右双引号
            char = input[++current];

            // 并将我们的“字符串”令牌添加到“令牌”数组中。
            tokens.push({
                type: 'string',
                value
            });

            continue;
        }

        // 最后一种类型的令牌将是“名称”令牌。这是一个序列
        // 字母而不是数字，这是我们 LISP 中函数的名称

        //
        //   (add 2 4)
        //    ^^^
        //    Name token
        //

        let LETTERS = /[a-z]/i;
        if (LETTERS.test(char)) {
            let value = '';

            // 同样，我们只是遍历所有推动它们的字母
            // 一个值。

            while (LETTERS.test(char)) {
                value += char;
                char = input[++current];
            }

            // 并将该值推送为类型为“name”的令牌并继续。
            tokens.push({
                type: 'name',
                value
            });

            continue;
        }

        // 最后，如果我们现在还没有匹配一个角色，我们将扔
        // 错误并完全退出。

        throw new TypeError('I dont know what this character is: ' + char);
    }

    // 然后在我们的“分词器”结束时，我们只需返回代币数组。
    return tokens;
}

/**
 * ============================================================================
* ヽ/❀o لۜ o\ノ
* 解析器!!!
 * ============================================================================
 */

/**
* 对于我们的解析器，我们将采用我们的令牌数组并将其转换为
* 阿斯特
 *
* [{ type: 'paren', value: '(' }, ...]   =>   { type: 'Program', body: [...] }
 */

// 好的，所以我们定义了一个接受我们的“令牌”数组的“解析器”函数。
function parser(tokens) {

    // 同样，我们保留一个“当前”变量，我们将将其用作游标。
    let current = 0;

    // 但是这次我们将使用递归而不是“while”循环。所以我们
    // 定义“步行”函数。

    function walk() {
        // 在步行函数中，我们首先抓取“当前”令牌。
        let token = tokens[current];
    }
}

















module.exports = {
    tokenizer
}